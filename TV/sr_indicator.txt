// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime & User Customized
// æŠ—æ’é’ˆç‰ˆ + 2Båè½¬è¯†åˆ« + é»‘è‰²èƒŒæ™¯é€‚é…

//@version=5
indicator("SRç©ºå•æŒ‡æ ‡v1", shorttitle="SRç©ºå•æŒ‡æ ‡v1", overlay=true, max_boxes_count=500, max_labels_count=500)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ›ï¸ å‚æ•°è®¾ç½®
// ---------------------------------------------------------------------------------------------------------------------{
group_trade = "Trade Logic (æ ¸å¿ƒæ­¢æŸä¼˜åŒ–)"
// ğŸ”¥ æ ¸å¿ƒä¼˜åŒ– 1ï¼šæŠ—æ’é’ˆå¼€å…³
bool  use_close_sl = input.bool(true, "Activate Anti-Wick Mode (å¼€å¯æŠ—æ’é’ˆå®ä½“æ­¢æŸ)", group=group_trade, tooltip="âœ… å¼€å¯åï¼šåªæœ‰å½“ Kçº¿å®ä½“æ”¶ç›˜ä»· > æ­¢æŸä»· æ—¶æ‰æ­¢æŸã€‚èƒ½æ‰›ä½å½±çº¿å‡çªç ´ã€‚\nğŸ›¡ï¸ å®‰å…¨æœºåˆ¶ï¼šä¸ºäº†é˜²æ­¢æš´æ‹‰ï¼Œå¦‚æœ High è¶…è¿‡ [æ­¢æŸä»· + 1.0 ATR] ä¼šå¼ºåˆ¶æ­¢æŸã€‚")
// ğŸ”¥ æ ¸å¿ƒä¼˜åŒ– 2ï¼šæœ€å¤§å°è¯•æ¬¡æ•°
int   max_retries  = input.int(3, "Max Retries per Zone (å•åŒºæœ€å¤§å°è¯•æ¬¡æ•°)", minval=1, group=group_trade, tooltip="åŒä¸€ä¸ªé˜»åŠ›åŒºï¼Œå¦‚æœè¿ç»­æ­¢æŸè¶…è¿‡ N æ¬¡ï¼Œå°±ä¸å†ç»™ä¿¡å·äº†ï¼Œé˜²æ­¢åå¤æ‰“è„¸ã€‚")
float sl_atr_mult  = input.float(1.0, "Stop Loss Buffer (ATRå€æ•°)", step=0.1, group=group_trade)
bool  show_all_info= input.bool(false, "Show All History (å¤ç›˜æ¨¡å¼)", group=group_trade)

group_rule = "Structure (ç»“æ„å®šä¹‰)"
int   leftLen     = input.int(90, "Pivot Lookback (å·¦ä¾§Kçº¿)", minval=10, group=group_rule) 
int   rightLen    = input.int(10, "Confirmation (å³ä¾§ç¡®è®¤)", minval=2, group=group_rule)
float merge_atr   = input.float(3.5, "Merge Threshold (åˆå¹¶åŠ›åº¦)", step=0.1, group=group_rule)
// ğŸ”¥ æ–°å¢ï¼šç ´åå®¹å¿åº¦
float break_tol   = input.float(0.5, "Break Tolerance ATR (ç ´åå®¹å¿åº¦)", step=0.1, group=group_rule, tooltip="å…è®¸æ”¶ç›˜ä»·è¶…è¿‡æ¡†é¡¶å¤šå°‘ATRè€Œä¸è§†ä¸ºç ´åï¼Ÿè¿™å¯¹æ•æ‰2Bå‡çªç ´è‡³å…³é‡è¦ã€‚")

group_view = "Smart View (æ™ºèƒ½è§†é‡)"
bool  use_smart    = input.bool(true, "Enable Smart View (å¼€å¯æ™ºèƒ½è§†é‡)", group=group_view)
float view_range   = input.float(15.0, "Visible Range % (æ˜¾ç¤ºèŒƒå›´)", step=1.0, group=group_view)
bool  auto_expand  = input.bool(true, "Auto Expand on 4H+ (4Hä»¥ä¸Šè‡ªåŠ¨å±•å¼€)", group=group_view)

group_ui = "UI Settings (ç•Œé¢å¾®è°ƒ)"
bool  show_touches = input.bool(false, "Show Zone Touches (æ˜¾ç¤ºè§¦ç¢°è®¡æ•°)", group=group_ui)
float text_offset  = input.float(6.0, "Text Height Offset (æ–‡å­—é«˜åº¦)", step=0.5, group=group_ui)
color col_text     = input.color(color.gray, "Info Text Color", group=group_ui)

group_sig = "Signals (ä¿¡å·è¿‡æ»¤)"
int   min_touches  = input.int(1, "Min Touches (æœ€å°‘è§¦ç¢°)", minval=1, group=group_sig)
int   global_cd    = input.int(30, "Time Cooldown (æ—¶é—´å†·å´)", minval=1, group=group_sig)
float price_filter = input.float(1.5, "Price Filter % (ä»·æ ¼è·ç¦»è¿‡æ»¤)", step=0.1, group=group_sig)

group_color = "Visuals (é¢œè‰²)"
color col_zone_bg = input.color(color.new(#f23645, 75), "Zone Background", group=group_color)
color col_zone_bd = input.color(color.new(#f23645, 50), "Zone Border", group=group_color)
color col_s_win   = input.color(#d32f2f, "S - Active (çº¢è‰²)", group=group_color)
color col_2b_win  = input.color(#9c27b0, "2B - Active (ç´«è‰²)", group=group_color) 
// ä¿®æ”¹ï¼šé»‘è‰²èƒŒæ™¯ä¸‹ï¼Œæ­¢æŸçš„æ ‡ç­¾ç”±é»‘è‰²æ”¹ä¸ºæµ…ç°è‰²ï¼Œå¦åˆ™çœ‹ä¸è§
color col_s_loss  = input.color(color.gray, "S - Stopped (ç°è‰²)", group=group_color)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ§  æ ¸å¿ƒæ•°æ®ç»“æ„
// ---------------------------------------------------------------------------------------------------------------------{
type Zone
    float top
    float bottom
    int   touches
    box   id
    label lbl_count
    bool  is_broken
    int   fail_count 

type Trade
    int   entry_idx
    float entry_high   
    float entry_atr    
    float sl_price
    float tp_zero_cost 
    label lbl_s        
    label lbl_info     
    bool  is_active    
    bool  hit_zero     
    bool  hit_sl       
    int   zone_idx     

var Zone[]  zones  = array.new<Zone>(0)
var Trade[] trades = array.new<Trade>(0)

var int   last_sig_idx   = 0 
var float last_sig_price = 0.0 
var bool  last_trade_hit_sl = false

float atr = ta.atr(14)
float ph  = ta.pivothigh(high, leftLen, rightLen)

// ---------------------------------------------------------------------------------------------------------------------}
// 1. é˜»åŠ›åŒºè¯†åˆ«
// ---------------------------------------------------------------------------------------------------------------------{
if not na(ph)
    float p_high = high[rightLen]
    float p_body = math.max(open[rightLen], close[rightLen])
    
    // ç¨å¾®åŠ åšä¸€ç‚¹æ¡†ï¼Œé¿å…å¤ªè–„
    if (p_high - p_body) < (atr * 0.2)
        p_body := p_high - (atr * 0.2)
        
    bool merged = false
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            Zone z = array.get(zones, i)
            if not z.is_broken
                float tolerance = atr * merge_atr
                if p_high <= (z.top + tolerance) and p_high >= (z.bottom - tolerance)
                    z.top    := math.max(z.top, p_high)
                    z.bottom := math.min(z.bottom, p_body) 
                    z.touches += 1
                    merged := true
                    break
    if not merged
        box b = box.new(bar_index - rightLen, p_high, bar_index, p_body, border_color=col_zone_bd, bgcolor=col_zone_bg, xloc=xloc.bar_index)
        label l = label.new(bar_index, p_high, "", color=col_zone_bd, textcolor=color.white, style=label.style_none)
        array.push(zones, Zone.new(p_high, p_body, 1, b, l, false, 0))

// ---------------------------------------------------------------------------------------------------------------------}
// 2. æ™ºèƒ½è§†é‡ & ä¿¡å·æ£€æµ‹
// ---------------------------------------------------------------------------------------------------------------------{
bool new_signal = false
bool is_htf = timeframe.isdwm or (timeframe.multiplier >= 240)

if array.size(zones) > 0
    for i = array.size(zones) - 1 to 0
        Zone z = array.get(zones, i)
        
        // --- å¯è§æ€§æ§åˆ¶ ---
        float dist_pct = math.abs(close - z.top) / close * 100
        bool is_visible = true
        if use_smart
            if auto_expand and is_htf
                is_visible := true
            else
                is_visible := (dist_pct <= view_range)

        if not z.is_broken
            if not is_visible
                // ä¸å¯è§æ—¶ï¼Œéšè—
                box.set_bgcolor(z.id, color.new(color.white, 100))
                box.set_border_color(z.id, color.new(color.white, 100))
                label.set_style(z.lbl_count, label.style_none)
                label.set_text(z.lbl_count, "")
            else
                box.set_right(z.id, bar_index + 10)
                
                // ğŸ”¥ ä¿®æ”¹ï¼šå¤±æ•ˆåˆ¤å®šåŠ å…¥ Tolerance
                if close > (z.top + atr * break_tol)
                    z.is_broken := true
                    // ğŸ”¥ ä¿®æ”¹ï¼šé»‘è‰²èƒŒæ™¯é€‚é…
                    // å¤±æ•ˆçš„æ¡†å˜æˆç™½è‰²è™šå½± (é€æ˜åº¦ 90%)
                    box.set_bgcolor(z.id, color.new(color.white, 90))
                    box.set_border_color(z.id, color.new(color.white, 85))
                    label.delete(z.lbl_count)
                else
                    // æœ‰æ•ˆçš„æ¡†ï¼šçº¢è‰²
                    box.set_bgcolor(z.id, col_zone_bg)
                    box.set_border_color(z.id, col_zone_bd)
                    if show_touches
                        label.set_xy(z.lbl_count, bar_index + 10, z.top)
                        label.set_text(z.lbl_count, str.tostring(z.touches))
                        label.set_style(z.lbl_count, label.style_label_down)
                        label.set_color(z.lbl_count, col_zone_bd)
                    else
                        label.set_style(z.lbl_count, label.style_none)
                        label.set_text(z.lbl_count, "")

        // --- C. ä¿¡å·æ£€æµ‹ ---
        if not z.is_broken and z.touches >= min_touches and not new_signal and z.fail_count < max_retries
            // åŸºç¡€æ¡ä»¶
            bool touch = high >= z.bottom
            bool is_bear = close < open
            
            // å†·å´ & ä»·æ ¼è¿‡æ»¤
            bool time_ok = (bar_index - last_sig_idx) > global_cd
            float diff = math.abs(close - last_sig_price) / last_sig_price * 100
            bool price_ok = (last_sig_price == 0.0) or (diff > price_filter)
            bool force_entry = last_trade_hit_sl
            
            bool entry_valid = (time_ok or force_entry) and (price_ok or force_entry) and barstate.isconfirmed
            
            if entry_valid
                // ğŸ”¥ æ¨¡å¼è¯†åˆ«
                // æ¨¡å¼ 1: æ ‡å‡†è§¦ç¢° (High åœ¨åŒºåŸŸå†…æˆ–ä¸‹æ–¹è§¦ç¢°)
                bool setup_std = touch and is_bear and high <= (z.top + atr * 0.1)
                
                // æ¨¡å¼ 2: 2B å‡çªç ´ (High åˆºç ´äº† Topï¼Œä½† Close æ”¶å›æ¥äº†)
                bool setup_2b = high > z.top and is_bear
                
                if (setup_std or setup_2b)
                    last_sig_idx := bar_index
                    last_sig_price := close
                    new_signal := true
                    last_trade_hit_sl := false 
                    
                    float trade_sl = z.top + (atr * sl_atr_mult)
                    
                    // é›¶æˆæœ¬è®¡ç®—
                    float trade_risk = trade_sl - close
                    float dist_to_zero = trade_risk * (0.7 / 0.3) 
                    float trade_tp_zero = close - dist_to_zero 
                    
                    // ğŸ·ï¸ æ ‡ç­¾é€»è¾‘
                    string txt_sig = setup_2b ? "2B" : "S"
                    color col_sig = setup_2b ? col_2b_win : col_s_win
                    
                    label s_lbl = label.new(bar_index, high, txt_sig, color=col_sig, style=label.style_label_down, textcolor=color.white, size=size.small)
                    label i_lbl = label.new(bar_index, high, "", color=color.new(color.white, 100), style=label.style_none, textcolor=col_text, size=size.normal)
                    
                    // è®°å½•
                    Trade t = Trade.new(bar_index, high, atr, trade_sl, trade_tp_zero, s_lbl, i_lbl, true, false, false, i)
                    array.push(trades, t)
                    alert("SRç©ºå•ä¿¡å·è§¦å‘: " + txt_sig, alert.freq_once_per_bar_close)

// ---------------------------------------------------------------------------------------------------------------------}
// 3. äº¤æ˜“è¿½è¸ª (ä¿æŒåŸé€»è¾‘)
// ---------------------------------------------------------------------------------------------------------------------{
if array.size(trades) > 0
    int last_idx = array.size(trades) - 1
    
    for k = 0 to last_idx
        Trade t = array.get(trades, k)
        
        if t.is_active
            // --- æ­¢æŸåˆ¤å®š ---
            bool sl_triggered = false
            if use_close_sl
                // æ¨¡å¼ A: å®ä½“æ­¢æŸ
                if close > t.sl_price
                    sl_triggered := true
                if high > (t.sl_price + atr * 1.0) // ç¾éš¾é£æ§
                    sl_triggered := true
            else
                // æ¨¡å¼ B: å½±çº¿æ­¢æŸ
                if high >= t.sl_price
                    sl_triggered := true
            
            if sl_triggered
                t.is_active := false
                t.hit_sl    := true
                last_trade_hit_sl := true 
                
                if t.zone_idx < array.size(zones)
                    Zone z_ref = array.get(zones, t.zone_idx)
                    z_ref.fail_count += 1
                
                // æ­¢æŸæ ‡ç­¾å˜è‰²
                label.set_color(t.lbl_s, col_s_loss) 
                alert("SRç©ºå•å·²æ­¢æŸ", alert.freq_once_per_bar)
                
            else if low <= t.tp_zero_cost and not t.hit_zero
                t.hit_zero := true
                // ğŸ’° å›¾æ ‡
                label.new(bar_index, low, "ğŸ’°", style=label.style_none, textcolor=color.yellow, size=size.tiny, yloc=yloc.belowbar)

        // --- æµ®åŠ¨ç›ˆäºæ˜¾ç¤º ---
        bool is_latest = (k == last_idx)
        bool show_this = show_all_info or is_latest
        
        if show_this
            string txt = "SL: " + str.tostring(t.sl_price, format.mintick) + "\n" + 
                         "Risk: -" + str.tostring((t.sl_price - t.entry_high)/t.entry_high*100, "#.2") + "%"
            
            if is_latest and not t.hit_zero and not t.hit_sl
                txt := txt + "\nTarget: " + str.tostring(t.tp_zero_cost, format.mintick)
            label.set_text(t.lbl_info, txt)
            float text_y_pos = t.entry_high + (t.entry_atr * text_offset)
            label.set_xy(t.lbl_info, t.entry_idx, text_y_pos)
            label.set_textcolor(t.lbl_info, t.hit_sl ? color.gray : col_text)
        else
            label.set_text(t.lbl_info, "")