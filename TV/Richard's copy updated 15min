// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime & User Customized
// æŠ—æ’é’ˆç‰ˆ + 2Båè½¬è¯†åˆ« + é»‘è‰²èƒŒæ™¯é€‚é…

//@version=5
strategy("SRç©ºå•ç­–ç•¥v1", shorttitle="SRç©ºå•ç­–ç•¥v1",
         overlay=true,
         pyramiding=20,
         initial_capital=10000,
         default_qty_type=strategy.cash,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         slippage=2,
         calc_on_every_tick=true,
         use_bar_magnifier=true,
         max_boxes_count=500,
         max_labels_count=500,
         max_lines_count=500)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ›ï¸ å‚æ•°è®¾ç½®
// ---------------------------------------------------------------------------------------------------------------------{
group_trade = "Trade Logic (æ ¸å¿ƒæ­¢æŸä¼˜åŒ–)"
// ğŸ”¥ æ ¸å¿ƒä¼˜åŒ– 1ï¼šæŠ—æ’é’ˆå¼€å…³
bool  use_close_sl = input.bool(true, "Activate Anti-Wick Mode (å¼€å¯æŠ—æ’é’ˆå®ä½“æ­¢æŸ)", group=group_trade, tooltip="âœ… å¼€å¯åï¼šåªæœ‰å½“ Kçº¿å®ä½“æ”¶ç›˜ä»· > æ­¢æŸä»· æ—¶æ‰æ­¢æŸã€‚èƒ½æ‰›ä½å½±çº¿å‡çªç ´ã€‚\nğŸ›¡ï¸ å®‰å…¨æœºåˆ¶ï¼šä¸ºäº†é˜²æ­¢æš´æ‹‰ï¼Œå¦‚æœ High è¶…è¿‡ [æ­¢æŸä»· + 1.0 ATR] ä¼šå¼ºåˆ¶æ­¢æŸã€‚")
// ğŸ”¥ æ ¸å¿ƒä¼˜åŒ– 2ï¼šæœ€å¤§å°è¯•æ¬¡æ•°
int   max_retries  = input.int(3, "Max Retries per Zone (å•åŒºæœ€å¤§å°è¯•æ¬¡æ•°)", minval=1, group=group_trade, tooltip="åŒä¸€ä¸ªé˜»åŠ›åŒºï¼Œå¦‚æœè¿ç»­æ­¢æŸè¶…è¿‡ N æ¬¡ï¼Œå°±ä¸å†ç»™ä¿¡å·äº†ï¼Œé˜²æ­¢åå¤æ‰“è„¸ã€‚")
float sl_atr_mult  = input.float(1.0, "Stop Loss Buffer (ATRå€æ•°)", step=0.1, group=group_trade)
bool  show_all_info= input.bool(false, "Show All History (å¤ç›˜æ¨¡å¼)", group=group_trade)

group_rule = "Structure (ç»“æ„å®šä¹‰)"
string zone_detection_tf = input.timeframe("240", "Zone Detection Timeframe (åŒºåŸŸæ£€æµ‹æ—¶é—´æ¡†æ¶)", group=group_rule, tooltip="åœ¨æ­¤æ—¶é—´æ¡†æ¶ä¸Šæ£€æµ‹é˜»åŠ›åŒºã€‚å»ºè®®ä½¿ç”¨é«˜æ—¶é—´æ¡†æ¶å¦‚4H(240)ã€1Dç­‰ï¼ŒåŒºåŸŸå°†åœ¨æ‰€æœ‰æ—¶é—´æ¡†æ¶ä¸Šå¯è§")
int   leftLen     = input.int(90, "Pivot Lookback (å·¦ä¾§Kçº¿)", minval=10, group=group_rule)
int   rightLen    = input.int(10, "Confirmation (å³ä¾§ç¡®è®¤)", minval=2, group=group_rule)
float merge_atr   = input.float(3.5, "Merge Threshold (åˆå¹¶åŠ›åº¦)", step=0.1, group=group_rule)
// ğŸ”¥ æ–°å¢ï¼šç ´åå®¹å¿åº¦
float break_tol   = input.float(0.5, "Break Tolerance ATR (ç ´åå®¹å¿åº¦)", step=0.1, group=group_rule, tooltip="å…è®¸æ”¶ç›˜ä»·è¶…è¿‡æ¡†é¡¶å¤šå°‘ATRè€Œä¸è§†ä¸ºç ´åï¼Ÿè¿™å¯¹æ•æ‰2Bå‡çªç ´è‡³å…³é‡è¦ã€‚")

group_view = "Smart View (æ™ºèƒ½è§†é‡)"
bool  use_smart    = input.bool(false, "Enable Smart View (å¼€å¯æ™ºèƒ½è§†é‡)", group=group_view)
float view_range   = input.float(15.0, "Visible Range % (æ˜¾ç¤ºèŒƒå›´)", step=1.0, group=group_view)
bool  auto_expand  = input.bool(true, "Auto Expand on 4H+ (4Hä»¥ä¸Šè‡ªåŠ¨å±•å¼€)", group=group_view)

group_ui = "UI Settings (ç•Œé¢å¾®è°ƒ)"
bool  show_touches = input.bool(false, "Show Zone Touches (æ˜¾ç¤ºè§¦ç¢°è®¡æ•°)", group=group_ui)
float text_offset  = input.float(6.0, "Text Height Offset (æ–‡å­—é«˜åº¦)", step=0.5, group=group_ui)
color col_text     = input.color(color.gray, "Info Text Color", group=group_ui)

group_sig = "Signals (ä¿¡å·è¿‡æ»¤)"
int   min_touches  = input.int(1, "Min Touches (æœ€å°‘è§¦ç¢°)", minval=1, group=group_sig)
int   global_cd    = input.int(30, "Time Cooldown (æ—¶é—´å†·å´)", minval=1, group=group_sig)
int   max_positions = input.int(5, "Max Concurrent Positions (æœ€å¤§å¹¶å‘ä»“ä½)", minval=1, maxval=20, group=group_sig, tooltip="åŒæ—¶å…è®¸çš„æœ€å¤§æŒä»“æ•°é‡")
float min_position_distance = input.float(1.5, "Min Position Distance % (ä»“ä½é—´æœ€å°è·ç¦»%)", step=0.1, group=group_sig, tooltip="æ–°ä»“ä½å…¥åœºä»·å¿…é¡»ä¸ç°æœ‰ä»“ä½å…¥åœºä»·ç›¸å·®è‡³å°‘æ­¤ç™¾åˆ†æ¯”")
float price_filter = input.float(1.5, "Price Filter % (ä»·æ ¼è·ç¦»è¿‡æ»¤)", step=0.1, group=group_sig)

group_color = "Visuals (é¢œè‰²)"
color col_zone_bg = input.color(color.new(#f23645, 75), "Zone Background", group=group_color)
color col_zone_bd = input.color(color.new(#f23645, 50), "Zone Border", group=group_color)
color col_s_win   = input.color(#d32f2f, "S - Active (çº¢è‰²)", group=group_color)
color col_2b_win  = input.color(#9c27b0, "2B - Active (ç´«è‰²)", group=group_color)
// ä¿®æ”¹ï¼šé»‘è‰²èƒŒæ™¯ä¸‹ï¼Œæ­¢æŸçš„æ ‡ç­¾ç”±é»‘è‰²æ”¹ä¸ºæµ…ç°è‰²ï¼Œå¦åˆ™çœ‹ä¸è§
color col_s_loss  = input.color(color.gray, "S - Stopped (ç°è‰²)", group=group_color)

// =====================================================================================================================
// ğŸ†• STRATEGY PARAMETERS (ç­–ç•¥å‚æ•°) - For backtesting and position management
// =====================================================================================================================
group_position = "ğŸ’° Position Sizing (ä»“ä½ç®¡ç†)"
float initial_capital = input.float(10000, "Initial Capital (åˆå§‹èµ„é‡‘)", group=group_position, tooltip="âš ï¸ ä»…ç”¨äºç­–ç•¥å£°æ˜ã€‚å®é™…ä»“ä½è®¡ç®—ä½¿ç”¨å½“å‰æƒç›Š (strategy.equity)")
float risk_per_trade  = input.float(0.5, "Risk Per Trade % (æ¯ç¬”é£é™©%)", step=0.1, group=group_position, tooltip="æ¯ç¬”äº¤æ˜“æœ€å¤§é£é™©å å½“å‰æƒç›Šçš„ç™¾åˆ†æ¯”")
float leverage        = input.float(5.0, "Leverage (æ æ†)", minval=1.0, step=0.5, group=group_position, tooltip="æœ€å¤§ä»“ä½å€æ•°ï¼šé™åˆ¶å•ç¬”äº¤æ˜“ä¸è¶…è¿‡ æƒç›Š Ã— æ æ†å€æ•°")
float commission_pct  = input.float(0.1, "Commission % (æ‰‹ç»­è´¹%)", step=0.01, group=group_position, tooltip="âš ï¸ ä»…ä¾›å‚è€ƒã€‚å®é™…æ‰‹ç»­è´¹åœ¨ç­–ç•¥å£°æ˜ä¸­è®¾ä¸º 0.1%")
int   slippage_ticks  = input.int(2, "Slippage Ticks (æ»‘ç‚¹)", group=group_position, tooltip="âš ï¸ ä»…ä¾›å‚è€ƒã€‚å®é™…æ»‘ç‚¹åœ¨ç­–ç•¥å£°æ˜ä¸­è®¾ä¸º 2 ticks")

group_strategy_sl = "ğŸ›‘ Strategy Stop Loss (ç­–ç•¥æ­¢æŸ)"
float strategy_sl_percent = input.float(2.0, "Stop Loss % Above Zone (æ­¢æŸ%)", step=0.1, group=group_strategy_sl, tooltip="ç­–ç•¥æ­¢æŸï¼šè®¾åœ¨åŒºåŸŸé¡¶éƒ¨ä¸Šæ–¹çš„ç™¾åˆ†æ¯”ã€‚ç”¨äºè®¡ç®—ä»“ä½å¤§å°å’Œå®é™…æ­¢æŸé€€å‡ºã€‚")

group_exit = "ğŸ¯ Profit Taking (æ­¢ç›ˆç­–ç•¥)"
float breakeven_ratio     = input.float(2.33, "Break-Even Profit Ratio (ä¿æœ¬å€æ•°)", step=0.1, group=group_exit, tooltip="å½“ç›ˆåˆ©è¾¾åˆ°é£é™©çš„æ­¤å€æ•°æ—¶ï¼Œå¹³æ‰éƒ¨åˆ†ä»“ä½ä¿æœ¬")
float breakeven_close_pct = input.float(30.0, "Break-Even Close % (ä¿æœ¬å¹³ä»“%)", step=5.0, minval=0, maxval=100, group=group_exit, tooltip="ä¿æœ¬æ—¶å¹³æ‰çš„ä»“ä½ç™¾åˆ†æ¯”")

// ğŸ¯ Three-Stage Profit Taking (TP1 + TP2 + TP3 = 100% of remaining position)
float tp1_atr_mult   = input.float(3.0, "TP1 ATR Multiplier (TP1 ATRå€æ•°)", step=0.5, group=group_exit, tooltip="TP1è§¦å‘è·ç¦»ï¼šå…¥åœºä»· - (ATR Ã— æ­¤å€æ•°)")
float tp1_close_pct  = input.float(40.0, "TP1 Close % (TP1å¹³ä»“%)", step=5.0, minval=0, maxval=100, group=group_exit, tooltip="TP1å¹³æ‰å‰©ä½™ä»“ä½çš„ç™¾åˆ†æ¯”")
float tp2_atr_mult   = input.float(5.0, "TP2 ATR Multiplier (TP2 ATRå€æ•°)", step=0.5, group=group_exit, tooltip="TP2è§¦å‘è·ç¦»ï¼šå…¥åœºä»· - (ATR Ã— æ­¤å€æ•°)")
float tp2_close_pct  = input.float(40.0, "TP2 Close % (TP2å¹³ä»“%)", step=5.0, minval=0, maxval=100, group=group_exit, tooltip="TP2å¹³æ‰å‰©ä½™ä»“ä½çš„ç™¾åˆ†æ¯”")
float tp3_atr_mult   = input.float(8.0, "TP3 ATR Multiplier (TP3 ATRå€æ•°)", step=0.5, group=group_exit, tooltip="TP3è§¦å‘è·ç¦»ï¼šå…¥åœºä»· - (ATR Ã— æ­¤å€æ•°)")
float tp3_close_pct  = input.float(20.0, "TP3 Close % (TP3å¹³ä»“%)", step=5.0, minval=0, maxval=100, group=group_exit, tooltip="TP3å¹³æ‰å‰©ä½™ä»“ä½çš„ç™¾åˆ†æ¯” (TP1+TP2+TP3åº”=100%)")

// âš ï¸ Validation: TP percentages must sum to 100%
float tp_total = tp1_close_pct + tp2_close_pct + tp3_close_pct
if tp_total != 100.0
    runtime.error("TP1% + TP2% + TP3% must equal 100%. Current total: " + str.tostring(tp_total) + "%")

group_backtest = "ğŸ“… Backtest Date Range (å›æµ‹æ—¥æœŸ)"
bool  use_date_range = input.bool(true, "Enable Date Range (å¯ç”¨æ—¥æœŸèŒƒå›´)", group=group_backtest)
int   start_year     = input.int(2020, "Start Year (å¼€å§‹å¹´ä»½)", minval=1970, group=group_backtest)
int   start_month    = input.int(1, "Start Month (å¼€å§‹æœˆä»½)", minval=1, maxval=12, group=group_backtest)
int   start_day      = input.int(1, "Start Day (å¼€å§‹æ—¥)", minval=1, maxval=31, group=group_backtest)
int   end_year       = input.int(2025, "End Year (ç»“æŸå¹´ä»½)", minval=1970, group=group_backtest)
int   end_month      = input.int(12, "End Month (ç»“æŸæœˆä»½)", minval=1, maxval=12, group=group_backtest)
int   end_day        = input.int(31, "End Day (ç»“æŸæ—¥)", minval=1, maxval=31, group=group_backtest)

group_advanced = "ğŸ”§ Advanced Settings (é«˜çº§è®¾ç½®)"
int   max_trades_history = input.int(100, "Max Trades in Memory (æœ€å¤§å†å²äº¤æ˜“æ•°)", minval=10, group=group_advanced, tooltip="ä¿ç•™åœ¨å†…å­˜ä¸­çš„æœ€å¤§äº¤æ˜“æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼")
bool  enable_logging     = input.bool(false, "Enable Debug Logging (å¼€å¯è°ƒè¯•æ—¥å¿—)", group=group_advanced, tooltip="åœ¨è­¦æŠ¥ä¸­æ˜¾ç¤ºè¯¦ç»†çš„ä»“ä½è®¡ç®—ä¿¡æ¯")

group_backtest_display = "ğŸ“Š Backtest Display (å›æµ‹æ˜¾ç¤º)"
bool  show_backtest_table = input.bool(true, "Show Backtest Table (æ˜¾ç¤ºå›æµ‹è¡¨æ ¼)", group=group_backtest_display)
string table_position = input.string("top_right", "Table Position (è¡¨æ ¼ä½ç½®)", options=["top_left", "top_center", "top_right", "middle_left", "middle_center", "middle_right", "bottom_left", "bottom_center", "bottom_right"], group=group_backtest_display)
string table_size = input.string("small", "Table Size (è¡¨æ ¼å¤§å°)", options=["tiny", "small", "normal", "large"], group=group_backtest_display)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ§  æ ¸å¿ƒæ•°æ®ç»“æ„
// ---------------------------------------------------------------------------------------------------------------------{
type Zone
    float top
    float bottom
    int   touches
    box   id
    label lbl_count
    bool  is_broken
    int   fail_count 

type Trade
    string trade_id            // Strategy trade ID
    int    entry_time
    float  entry_price
    float  entry_high
    float  entry_atr
    float  zone_top
    float  sl_price
    float  breakeven_price
    float  tp1_price           // ğŸ¯ TP1 target price
    float  tp2_price           // ğŸ¯ TP2 target price
    float  tp3_price           // ğŸ¯ TP3 target price
    int    exit_time           // ğŸ†• Exit timestamp for backtest
    float  exit_price          // ğŸ†• Exit price for backtest
    string exit_reason         // ğŸ†• Exit reason: "SL", "BE", "TP1", "TP2", "TP3"
    label  lbl_s
    label  lbl_info
    bool   is_active
    bool   hit_breakeven
    bool   hit_sl
    bool   hit_tp1             // ğŸ¯ TP1 reached
    bool   hit_tp2             // ğŸ¯ TP2 reached
    bool   hit_tp3             // ğŸ¯ TP3 reached
    int    zone_idx
    float  position_qty        // Original position size
    float  remaining_qty       // ğŸ†• Remaining after partials
    float  realized_pnl        // ğŸ†• Realized P&L
    bool   breakeven_closed     

var Zone[]  zones  = array.new<Zone>(0)
var Trade[] trades = array.new<Trade>(0)

var int   last_sig_idx   = 0
var float last_sig_price = 0.0

// ğŸ†• Backtest Metrics Tracking
var float total_realized_pnl = 0.0
var int   total_trades = 0
var int   winning_trades = 0
var int   losing_trades = 0
var float total_win_pnl = 0.0
var float total_loss_pnl = 0.0
var float peak_equity = initial_capital
var float max_drawdown = 0.0
var float current_equity = initial_capital

// ğŸ†• Backtest date range check
int start_timestamp = timestamp(start_year, start_month, start_day, 0, 0)
int end_timestamp   = timestamp(end_year, end_month, end_day, 23, 59)
bool in_date_range  = not use_date_range or (time >= start_timestamp and time <= end_timestamp)

// =====================================================================================================================
// ğŸ†• HIGHER TIMEFRAME DATA FETCHING (for multi-timeframe zone detection)
// =====================================================================================================================
// Fetch pivot AND pivot bar's data in ONE synchronized call (all offsets evaluated in HTF context)
[htf_ph, htf_ph_high, htf_ph_open, htf_ph_close, htf_ph_time] = request.security(syminfo.tickerid, zone_detection_tf, [ta.pivothigh(high, leftLen, rightLen), high[rightLen], open[rightLen], close[rightLen], time[rightLen]], lookahead=barmerge.lookahead_off)

// Fetch current HTF data for zone breaking and signal detection
[htf_high, htf_low, htf_open, htf_close, htf_time] = request.security(syminfo.tickerid, zone_detection_tf, [high, low, open, close, time], lookahead=barmerge.lookahead_off)

float htf_atr = request.security(syminfo.tickerid, zone_detection_tf, ta.atr(14), lookahead=barmerge.lookahead_off)
bool htf_bar_confirmed = request.security(syminfo.tickerid, zone_detection_tf, barstate.isconfirmed, lookahead=barmerge.lookahead_on)

// Current timeframe data (still needed for display and certain checks)
float atr = ta.atr(14)
float ph  = ta.pivothigh(high, leftLen, rightLen)

// ---------------------------------------------------------------------------------------------------------------------}
// 1. é˜»åŠ›åŒºè¯†åˆ« (ä½¿ç”¨é«˜æ—¶é—´æ¡†æ¶æ•°æ® - Using Higher Timeframe Data)
// ---------------------------------------------------------------------------------------------------------------------{
if not na(htf_ph) and htf_bar_confirmed
    // ğŸ†• Use synchronized pivot bar data (fetched together, all from same HTF bar)
    float p_high = htf_ph_high
    float p_body = math.max(htf_ph_open, htf_ph_close)

    // ç¨å¾®åŠ åšä¸€ç‚¹æ¡†ï¼Œé¿å…å¤ªè–„ (use HTF ATR)
    if (p_high - p_body) < (htf_atr * 0.2)
        p_body := p_high - (htf_atr * 0.2)

    bool merged = false
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            Zone z = array.get(zones, i)
            if not z.is_broken
                float tolerance = htf_atr * merge_atr  // ğŸ†• Use HTF ATR for merging
                if p_high <= (z.top + tolerance) and p_high >= (z.bottom - tolerance)
                    z.top    := math.max(z.top, p_high)
                    z.bottom := math.min(z.bottom, p_body)
                    z.touches += 1
                    merged := true
                    break
    if not merged
        // Use synchronized pivot bar time for box left coordinate
        box b = box.new(htf_ph_time, p_high, htf_time, p_body, border_color=col_zone_bd, bgcolor=col_zone_bg, xloc=xloc.bar_time)
        label l = label.new(htf_time, p_high, "", color=col_zone_bd, textcolor=color.white, style=label.style_none, xloc=xloc.bar_time)
        array.push(zones, Zone.new(p_high, p_body, 1, b, l, false, 0))

// ---------------------------------------------------------------------------------------------------------------------}
// 2. æ™ºèƒ½è§†é‡ & ä¿¡å·æ£€æµ‹ (ä½¿ç”¨é«˜æ—¶é—´æ¡†æ¶æ•°æ® - Using Higher Timeframe Data)
// ---------------------------------------------------------------------------------------------------------------------{
bool new_signal = false
bool is_htf_chart = timeframe.isdwm or (timeframe.multiplier >= 240)

if array.size(zones) > 0
    for i = array.size(zones) - 1 to 0
        Zone z = array.get(zones, i)

        // --- å¯è§æ€§æ§åˆ¶ (ä½¿ç”¨å½“å‰æ—¶é—´æ¡†æ¶çš„ä»·æ ¼ä»¥ä¾¿åœ¨ä½æ—¶é—´æ¡†æ¶ä¸Šå¯è§) ---
        float dist_pct = math.abs(close - z.top) / close * 100
        bool is_visible = true
        if use_smart
            if auto_expand and is_htf_chart
                is_visible := true
            else
                is_visible := (dist_pct <= view_range)

        if not z.is_broken
            if not is_visible
                // ä¸å¯è§æ—¶ï¼Œéšè—
                box.set_bgcolor(z.id, color.new(color.white, 100))
                box.set_border_color(z.id, color.new(color.white, 100))
                label.set_style(z.lbl_count, label.style_none)
                label.set_text(z.lbl_count, "")
            else
                box.set_right(z.id, time)  // Extend zone to current time

                // ğŸ”¥ ä¿®æ”¹ï¼šå¤±æ•ˆåˆ¤å®šåŠ å…¥ Tolerance (ä½¿ç”¨é«˜æ—¶é—´æ¡†æ¶æ•°æ®æ£€æµ‹ç ´å)
                if htf_close > (z.top + htf_atr * break_tol)  // Use HTF data to determine if zone is broken
                    z.is_broken := true
                    // ğŸ”¥ ä¿®æ”¹ï¼šé»‘è‰²èƒŒæ™¯é€‚é…
                    // å¤±æ•ˆçš„æ¡†å˜æˆç™½è‰²è™šå½± (é€æ˜åº¦ 90%)
                    box.set_bgcolor(z.id, color.new(color.white, 90))
                    box.set_border_color(z.id, color.new(color.white, 85))
                    label.delete(z.lbl_count)
                else
                    // æœ‰æ•ˆçš„æ¡†ï¼šçº¢è‰²
                    box.set_bgcolor(z.id, col_zone_bg)
                    box.set_border_color(z.id, col_zone_bd)
                    if show_touches
                        label.set_xy(z.lbl_count, time, z.top)  // Use current time for label position
                        label.set_text(z.lbl_count, str.tostring(z.touches))
                        label.set_style(z.lbl_count, label.style_label_down)
                        label.set_color(z.lbl_count, col_zone_bd)
                    else
                        label.set_style(z.lbl_count, label.style_none)
                        label.set_text(z.lbl_count, "")

        // --- C. ä¿¡å·æ£€æµ‹ (ä½¿ç”¨åŒºåŸŸæ£€æµ‹æ—¶é—´æ¡†æ¶ - Zone Detection TF) ---
        if not z.is_broken and z.touches >= min_touches and not new_signal and z.fail_count < max_retries
            // ğŸ”¥ IMPORTANT: Signal detection ALWAYS uses Zone Detection TF (e.g., 4H)
            // This ensures we only generate signals when higher TF candles touch zones
            // NOT on every lower TF candle (which would create too many trades)
            float signal_high = htf_high
            float signal_low = htf_low
            float signal_close = htf_close
            float signal_open = htf_open
            float signal_atr = htf_atr

            // åŸºç¡€æ¡ä»¶ (ä½¿ç”¨åŒºåŸŸæ£€æµ‹æ—¶é—´æ¡†æ¶æ£€æµ‹è§¦ç¢° - 4H)
            bool touch = signal_high >= z.bottom
            bool is_bear = signal_close < signal_open

            // å†·å´ & ä»·æ ¼è¿‡æ»¤
            bool time_ok = (bar_index - last_sig_idx) > global_cd
            bool price_ok = (last_sig_price == 0.0) or (math.abs(signal_close - last_sig_price) / last_sig_price * 100 > price_filter)

            // ğŸ†• Check if new position would be too close to any existing open position
            bool too_close_to_existing = false
            if array.size(trades) > 0
                for t_idx = 0 to array.size(trades) - 1
                    Trade existing = array.get(trades, t_idx)
                    if existing.is_active
                        float price_diff_pct = math.abs(close - existing.entry_price) / existing.entry_price * 100
                        if price_diff_pct < min_position_distance
                            too_close_to_existing := true
                            break

            // ğŸ†• Check concurrent position limit
            int active_position_count = 0
            if array.size(trades) > 0
                for t_idx = 0 to array.size(trades) - 1
                    if array.get(trades, t_idx).is_active
                        active_position_count += 1

            bool position_limit_reached = active_position_count >= max_positions

            // Entry confirmation: wait for current chart bar close
            bool bar_confirmed = barstate.isconfirmed

            bool entry_valid = time_ok and price_ok and not too_close_to_existing and not position_limit_reached and bar_confirmed and in_date_range

            if entry_valid
                // ğŸ”¥ æ¨¡å¼è¯†åˆ« (ä½¿ç”¨é€‰å®šæ—¶é—´æ¡†æ¶æ£€æµ‹è§¦ç¢°)
                // æ¨¡å¼ 1: æ ‡å‡†è§¦ç¢° (Signal TF High åœ¨åŒºåŸŸå†…æˆ–ä¸‹æ–¹è§¦ç¢°)
                bool setup_std = touch and is_bear and signal_high <= (z.top + signal_atr * 0.1)

                // æ¨¡å¼ 2: 2B å‡çªç ´ (Signal TF High åˆºç ´äº† Topï¼Œä½† Close æ”¶å›æ¥äº†)
                bool setup_2b = signal_high > z.top and is_bear

                if (setup_std or setup_2b)
                    last_sig_idx := bar_index
                    last_sig_price := close
                    new_signal := true

                    // Entry at current chart bar close
                    float entry_price = close
                    float entry_high = high

                    // ğŸ†• Strategy Stop Loss: Percentage above zone top
                    float trade_sl = z.top * (1 + strategy_sl_percent / 100)
                    float stop_distance = trade_sl - entry_price

                    // ğŸ›¡ï¸ Minimum stop distance (prevent extreme positions from tiny stops)
                    float min_stop = htf_atr * 0.5
                    if stop_distance < min_stop
                        stop_distance := min_stop
                        trade_sl := entry_price + stop_distance  // Adjust SL accordingly

                    // ğŸ†• Position Sizing (Risk-based with leverage for margin)
                    float risk_amount = initial_capital * (risk_per_trade / 100)  // Risk 0.5% of initial capital
                    float position_qty = risk_amount / stop_distance  // Base position from risk

                    // Check margin requirement with leverage
                    float position_value = position_qty * entry_price
                    float margin_required = position_value / leverage

                    // Safety check: Ensure we have enough capital for margin
                    if margin_required > initial_capital
                        position_qty := (initial_capital * leverage) / entry_price

                    // ğŸ†• Exit Targets
                    float profit_for_breakeven = stop_distance * breakeven_ratio
                    float breakeven_price = entry_price - profit_for_breakeven

                    // ğŸ¯ Calculate TP1, TP2, TP3 prices (for SHORT: lower prices = profit)
                    float tp1_price = entry_price - (htf_atr * tp1_atr_mult)
                    float tp2_price = entry_price - (htf_atr * tp2_atr_mult)
                    float tp3_price = entry_price - (htf_atr * tp3_atr_mult)

                    // ğŸ·ï¸ æ ‡ç­¾é€»è¾‘ (Keep original)
                    string txt_sig = setup_2b ? "2B" : "S"
                    color col_sig = setup_2b ? col_2b_win : col_s_win

                    // ğŸ†• Enter SHORT position
                    string trade_id = "SHORT_" + str.tostring(bar_index)
                    strategy.entry(trade_id, strategy.short, qty=position_qty, comment=txt_sig)

                    // ğŸ›‘ Set hard stop-loss order (guarantees exit at SL price, no disaster protection needed)
                    strategy.exit("SL_" + trade_id, from_entry=trade_id, stop=trade_sl, comment="SL")

                    // ğŸ·ï¸ Create labels AFTER successful entry (using current time and entry high)
                    label s_lbl = label.new(time, entry_high, txt_sig, color=col_sig, style=label.style_label_down, textcolor=color.white, size=size.small, xloc=xloc.bar_time)  // Use entry high
                    label i_lbl = label.new(time, entry_high, "", color=color.new(color.white, 100), style=label.style_none, textcolor=col_text, size=size.normal, xloc=xloc.bar_time)  // Use entry high

                    // ğŸ“Š Logging (if enabled)
                    if enable_logging
                        log.info("Entry: " + str.tostring(entry_price) +
                                 " | SL: " + str.tostring(trade_sl) +
                                 " | Stop Dist: " + str.tostring(stop_distance) +
                                 " | Risk: $" + str.tostring(risk_amount) +
                                 " | Position: $" + str.tostring(position_qty) +
                                 " | Equity: $" + str.tostring(current_equity))

                    // è®°å½•äº¤æ˜“
                    Trade t = Trade.new(trade_id, time, entry_price, entry_high, htf_atr, z.top, trade_sl,
                                       breakeven_price,
                                       tp1_price, tp2_price, tp3_price,  // ğŸ¯ TP targets
                                       0, 0.0, "",  // exit_time, exit_price, exit_reason (filled on close)
                                       s_lbl, i_lbl,
                                       true, false, false, false, false, false,  // is_active, hit_breakeven, hit_sl, hit_tp1, hit_tp2, hit_tp3
                                       i,  // zone_idx
                                       position_qty, position_qty, 0.0, false)  // position_qty, remaining_qty, realized_pnl, breakeven_closed
                    array.push(trades, t)
                    alert("SRç©ºå•ä¿¡å·è§¦å‘ (Zone:" + zone_detection_tf + "): " + txt_sig, alert.freq_once_per_bar_close)

// ---------------------------------------------------------------------------------------------------------------------}
// 3. äº¤æ˜“è¿½è¸ª (ä¿æŒåŸé€»è¾‘)
// ---------------------------------------------------------------------------------------------------------------------{
if array.size(trades) > 0
    for k = 0 to array.size(trades) - 1
        Trade t = array.get(trades, k)

        if t.is_active
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            // EXIT 1: Stop Loss Detection (strategy.exit() handles actual close)
            // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            // Hard SL order closes position automatically at exact SL price (on touch)
            // We just need to detect when it happened and update tracking
            // Before break-even: SL at original level (above zone)
            // After break-even: SL moved to entry price (zero loss protection)
            float current_sl = t.hit_breakeven ? t.entry_price : t.sl_price
            bool sl_hit = high >= current_sl

            if sl_hit
                // Position already closed by strategy.exit() - just update tracking
                t.is_active := false
                t.hit_sl := true

                // Increment zone failure count ONLY if SL hit before break-even (actual loss)
                // If SL hit after break-even, trade is still profitable overall (30% was locked)
                if not t.hit_breakeven and t.zone_idx < array.size(zones)
                    Zone z_ref = array.get(zones, t.zone_idx)
                    z_ref.fail_count += 1

                label.set_color(t.lbl_s, col_s_loss)
                alert("SRç©ºå•å·²æ­¢æŸ", alert.freq_once_per_bar)

            else if not sl_hit
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // EXIT 2: Break-Even Partial Close (Take out original investment)
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                if low <= t.breakeven_price and not t.breakeven_closed
                    // Cancel original SL exit order
                    strategy.cancel("SL_" + t.trade_id)

                    // Close partial position (30%) to secure initial investment
                    float close_qty = t.position_qty * (breakeven_close_pct / 100)
                    strategy.close(t.trade_id, qty=close_qty, comment="BE")

                    t.breakeven_closed := true
                    t.hit_breakeven := true
                    t.remaining_qty := t.position_qty - close_qty  // Update remaining position

                    // ğŸ›¡ï¸ Set NEW hard SL at entry price for remaining 70% (zero loss protection)
                    // For SHORT: If price comes back up to entry, close remaining at break-even
                    strategy.exit("SL_BE_" + t.trade_id, from_entry=t.trade_id,
                                 stop=t.entry_price, comment="SL")

                    // ğŸ’° Visual indicator
                    label.new(bar_index, low, "ğŸ’°", style=label.style_none,
                             textcolor=color.yellow, size=size.tiny, yloc=yloc.belowbar)
                    alert("SRç©ºå•è¾¾åˆ°ä¿æœ¬ç‚¹", alert.freq_once_per_bar)

                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // EXIT 3-5: TP1, TP2, TP3 (Scale out of remaining position)
                // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                // Only monitor TPs after break-even is hit
                if t.hit_breakeven
                    // TP1: Close X% of remaining position
                    if not t.hit_tp1 and low <= t.tp1_price
                        float tp1_qty = t.remaining_qty * (tp1_close_pct / 100)
                        strategy.close(t.trade_id, qty=tp1_qty, comment="TP1")
                        t.hit_tp1 := true
                        t.remaining_qty := t.remaining_qty - tp1_qty

                        label.new(bar_index, low, "ğŸ¯1", style=label.style_none,
                                 textcolor=color.green, size=size.small, yloc=yloc.belowbar)
                        alert("SRç©ºå• TP1 è¾¾æˆ", alert.freq_once_per_bar)

                    // TP2: Close Y% of remaining position
                    else if t.hit_tp1 and not t.hit_tp2 and low <= t.tp2_price
                        float tp2_qty = t.remaining_qty * (tp2_close_pct / 100)
                        strategy.close(t.trade_id, qty=tp2_qty, comment="TP2")
                        t.hit_tp2 := true
                        t.remaining_qty := t.remaining_qty - tp2_qty

                        label.new(bar_index, low, "ğŸ¯2", style=label.style_none,
                                 textcolor=color.green, size=size.small, yloc=yloc.belowbar)
                        alert("SRç©ºå• TP2 è¾¾æˆ", alert.freq_once_per_bar)

                    // TP3: Close remaining 100%
                    else if t.hit_tp2 and not t.hit_tp3 and low <= t.tp3_price
                        strategy.close(t.trade_id, comment="TP3")
                        t.hit_tp3 := true
                        t.is_active := false
                        t.remaining_qty := 0.0

                        label.new(bar_index, low, "ğŸ¯3", style=label.style_none,
                                 textcolor=color.green, size=size.normal, yloc=yloc.belowbar)
                        alert("SRç©ºå• TP3 å…¨éƒ¨æ­¢ç›ˆ", alert.freq_once_per_bar)

        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // Info Display
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        bool is_latest = (k == array.size(trades) - 1)
        bool show_this = show_all_info or is_latest

        if show_this
            float risk_pct = (t.sl_price - t.entry_price) / t.entry_price * 100
            string txt = "Entry: " + str.tostring(t.entry_price, format.mintick) + "\n" +
                         "SL: " + str.tostring(t.sl_price, format.mintick) +
                         " (+" + str.tostring(risk_pct, "#.2") + "%)\n"

            if not t.hit_sl and not t.breakeven_closed
                txt := txt + "BE: " + str.tostring(t.breakeven_price, format.mintick) + "\n"

            // Trailing stop is dynamic, shown visually when triggered

            label.set_text(t.lbl_info, txt)
            float text_y_pos = t.entry_high + (t.entry_atr * text_offset)
            label.set_xy(t.lbl_info, t.entry_time, text_y_pos)
            label.set_textcolor(t.lbl_info, t.hit_sl ? color.gray : col_text)
        else
            label.set_text(t.lbl_info, "")

// ğŸ§¹ Trade Array Cleanup (prevent memory leak)
// Remove old inactive trades if array grows too large
if array.size(trades) > max_trades_history
    int trades_to_remove = array.size(trades) - max_trades_history
    for j = 0 to trades_to_remove - 1
        if not array.get(trades, 0).is_active
            // Remove oldest inactive trade
            Trade old_trade = array.shift(trades)
            // Clean up labels
            label.delete(old_trade.lbl_s)
            label.delete(old_trade.lbl_info)
        else
            break  // Stop if we hit an active trade