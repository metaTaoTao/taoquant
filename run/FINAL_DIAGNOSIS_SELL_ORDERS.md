# 卖出订单触发和执行逻辑诊断总结

## 关键发现

### 1. 订单放置情况
- 买入订单执行次数: 40次
- 卖出订单放置次数: 20次（只有买入订单的一半）
- 最终待处理卖出订单数: 1

### 2. 订单触发情况
- 价格触及卖出网格次数: 250次
- 卖出订单触发次数: 0次
- 价格触及率: 0.00%

### 3. 应该触发但未触发的情况
- 有4次价格触及且应该触发（价格触及、long_exposure > 0）
- 但卖出订单没有被触发

## 问题分析

### 问题1: 卖出订单放置数量不足
- 买入订单执行40次，但卖出订单只放置20次
- 可能原因：
  1. `place_pending_order` 检查订单是否已存在，如果已存在就不放置
  2. 或者卖出订单被移除了

### 问题2: 卖出订单没有被触发
- 价格触及250次，但卖出订单触发0次
- 可能原因：
  1. `check_limit_order_triggers` 只返回第一个被触发的订单
  2. 如果同一根K线中买入订单先被触发，卖出订单可能因为 `last_checked_bar` 被跳过
  3. 或者卖出订单的 `triggered` 标志被错误地设置了

### 问题3: `check_limit_order_triggers` 只返回第一个订单
- 这是核心问题：如果同一根K线中有多个订单被触发（买入和卖出），只会返回第一个
- 虽然我们在 `simple_lean_runner` 中循环调用 `on_data`，但问题是：
  1. 第一次调用时，如果买入订单先被触发，就返回买入订单
  2. 第二次调用时，卖出订单可能因为 `last_checked_bar` 被跳过

## 解决方案

### 方案1: 修改 `check_limit_order_triggers` 返回所有被触发的订单
- 优点：可以处理同一根K线中的所有订单
- 缺点：需要修改 `on_data` 的逻辑

### 方案2: 修改 `last_checked_bar` 的逻辑
- 只在订单被实际触发且执行成功时才设置 `last_checked_bar`
- 如果订单被触发但执行失败，重置 `last_checked_bar` 以允许重新检查

### 方案3: 分别检查买入和卖出订单
- 在 `check_limit_order_triggers` 中，先检查所有买入订单，再检查所有卖出订单
- 或者，分别调用 `check_buy_triggers` 和 `check_sell_triggers`

## 建议的修复

1. **修改 `check_limit_order_triggers` 返回所有被触发的订单列表**
   - 这样可以确保同一根K线中的所有订单都能被处理

2. **修改 `last_checked_bar` 的逻辑**
   - 只在订单被实际触发且执行成功时才设置
   - 如果订单被触发但执行失败，重置 `last_checked_bar`

3. **检查 `place_pending_order` 的逻辑**
   - 确保卖出订单被正确放置
   - 检查是否有重复订单检查导致订单没有被放置

