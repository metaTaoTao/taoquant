// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime & User Customized
// æ”¯æ’‘ä½åšå¤šæŒ‡æ ‡ - é˜»åŠ›ä½åšç©ºæŒ‡æ ‡çš„é•œåƒç‰ˆæœ¬

//@version=5
indicator("SRå¤šå•æŒ‡æ ‡v1", shorttitle="SRå¤šå•æŒ‡æ ‡v1", overlay=true, max_boxes_count=500, max_labels_count=500)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ›ï¸ å‚æ•°è®¾ç½®
// ---------------------------------------------------------------------------------------------------------------------{
group_trade = "Trade Logic (æ ¸å¿ƒæ­¢æŸä¼˜åŒ–)"
bool  use_close_sl = input.bool(true, "Activate Anti-Wick Mode (å¼€å¯æŠ—æ’é’ˆå®ä½“æ­¢æŸ)", group=group_trade, tooltip="âœ… å¼€å¯åï¼šåªæœ‰å½“ Kçº¿å®ä½“æ”¶ç›˜ä»· < æ­¢æŸä»· æ—¶æ‰æ­¢æŸã€‚èƒ½æ‰›ä½å½±çº¿å‡çªç ´ã€‚\nğŸ›¡ï¸ å®‰å…¨æœºåˆ¶ï¼šä¸ºäº†é˜²æ­¢æš´è·Œï¼Œå¦‚æœ Low ä½äº [æ­¢æŸä»· - 1.0 ATR] ä¼šå¼ºåˆ¶æ­¢æŸã€‚")
int   max_retries  = input.int(3, "Max Retries per Zone (å•åŒºæœ€å¤§å°è¯•æ¬¡æ•°)", minval=1, group=group_trade, tooltip="åŒä¸€ä¸ªæ”¯æ’‘åŒºï¼Œå¦‚æœè¿ç»­æ­¢æŸè¶…è¿‡ N æ¬¡ï¼Œå°±ä¸å†ç»™ä¿¡å·äº†ï¼Œé˜²æ­¢åå¤æ‰“è„¸ã€‚")
float sl_atr_mult  = input.float(1.0, "Stop Loss Buffer (ATRå€æ•°)", step=0.1, group=group_trade)
bool  show_all_info= input.bool(false, "Show All History (å¤ç›˜æ¨¡å¼)", group=group_trade)

group_rule = "Structure (ç»“æ„å®šä¹‰)"
int   leftLen     = input.int(90, "Pivot Lookback (å·¦ä¾§Kçº¿)", minval=10, group=group_rule) 
int   rightLen    = input.int(10, "Confirmation (å³ä¾§ç¡®è®¤)", minval=2, group=group_rule)
float merge_atr   = input.float(3.5, "Merge Threshold (åˆå¹¶åŠ›åº¦)", step=0.1, group=group_rule)
float break_tol   = input.float(0.5, "Break Tolerance ATR (ç ´åå®¹å¿åº¦)", step=0.1, group=group_rule, tooltip="å…è®¸æ”¶ç›˜ä»·ä½äºæ¡†åº•å¤šå°‘ATRè€Œä¸è§†ä¸ºç ´åï¼Ÿè¿™å¯¹æ•æ‰2Bå‡çªç ´è‡³å…³é‡è¦ã€‚")

group_view = "Smart View (æ™ºèƒ½è§†é‡)"
bool  use_smart    = input.bool(true, "Enable Smart View (å¼€å¯æ™ºèƒ½è§†é‡)", group=group_view)
float view_range   = input.float(15.0, "Visible Range % (æ˜¾ç¤ºèŒƒå›´)", step=1.0, group=group_view)
bool  auto_expand  = input.bool(true, "Auto Expand on 4H+ (4Hä»¥ä¸Šè‡ªåŠ¨å±•å¼€)", group=group_view)

group_ui = "UI Settings (ç•Œé¢å¾®è°ƒ)"
bool  show_touches = input.bool(false, "Show Zone Touches (æ˜¾ç¤ºè§¦ç¢°è®¡æ•°)", group=group_ui)
float text_offset  = input.float(6.0, "Text Height Offset (æ–‡å­—é«˜åº¦)", step=0.5, group=group_ui)
color col_text     = input.color(color.gray, "Info Text Color", group=group_ui)

group_sig = "Signals (ä¿¡å·è¿‡æ»¤)"
int   min_touches  = input.int(1, "Min Touches (æœ€å°‘è§¦ç¢°)", minval=1, group=group_sig)
int   global_cd    = input.int(30, "Time Cooldown (æ—¶é—´å†·å´)", minval=1, group=group_sig)
float price_filter = input.float(1.5, "Price Filter % (ä»·æ ¼è·ç¦»è¿‡æ»¤)", step=0.1, group=group_sig)

group_color = "Visuals (é¢œè‰²)"
color col_zone_bg = input.color(color.new(#27AE60, 75), "Zone Background", group=group_color)  // ç»¿è‰²æ”¯æ’‘åŒº
color col_zone_bd = input.color(color.new(#27AE60, 50), "Zone Border", group=group_color)
color col_l_win   = input.color(#27AE60, "L - Active (ç»¿è‰²)", group=group_color)  // L = Long
color col_2b_win  = input.color(#9c27b0, "2B - Active (ç´«è‰²)", group=group_color) 
color col_l_loss  = input.color(color.gray, "L - Stopped (ç°è‰²)", group=group_color)

// ---------------------------------------------------------------------------------------------------------------------}
// ğŸ§  æ ¸å¿ƒæ•°æ®ç»“æ„
// ---------------------------------------------------------------------------------------------------------------------{
type Zone
    float top
    float bottom
    int   touches
    box   id
    label lbl_count
    bool  is_broken
    int   fail_count 

type Trade
    int   entry_idx
    float entry_low   
    float entry_atr    
    float sl_price
    float tp_zero_cost 
    label lbl_l        
    label lbl_info     
    bool  is_active    
    bool  hit_zero     
    bool  hit_sl       
    int   zone_idx     

var Zone[]  zones  = array.new<Zone>(0)
var Trade[] trades = array.new<Trade>(0)

var int   last_sig_idx   = 0 
var float last_sig_price = 0.0 
var bool  last_trade_hit_sl = false

float atr = ta.atr(14)
float pl  = ta.pivotlow(low, leftLen, rightLen)  // é•œåƒï¼špivotlow

// ---------------------------------------------------------------------------------------------------------------------}
// 1. æ”¯æ’‘åŒºè¯†åˆ«
// ---------------------------------------------------------------------------------------------------------------------{
if not na(pl)
    float p_low = low[rightLen]
    float p_body = math.min(open[rightLen], close[rightLen])  // é•œåƒï¼šå–å®ä½“åº•éƒ¨
    
    // ğŸ”¥ æ”¯æ’‘åŒºå®šä¹‰ï¼ˆé•œåƒç©ºå•é€»è¾‘ï¼‰ï¼š
    // ç©ºå•ï¼štop = p_highï¼ˆæœ€é«˜ä»·ï¼‰ï¼Œbottom = p_bodyï¼ˆå®ä½“é¡¶éƒ¨ï¼‰
    // å¤šå•ï¼štop = p_bodyï¼ˆå®ä½“åº•éƒ¨ï¼‰ï¼Œbottom = p_lowï¼ˆæœ€ä½ä»·ï¼‰
    // æ³¨æ„ï¼šp_body æ˜¯å®ä½“åº•éƒ¨ï¼Œp_low æ˜¯æœ€ä½ä»·ï¼Œæ­£å¸¸æƒ…å†µä¸‹ p_body >= p_low
    // ä½†å¦‚æœ K çº¿æœ‰ä¸‹å½±çº¿ï¼Œp_low < p_bodyï¼Œæ­¤æ—¶éœ€è¦ç¡®ä¿ top >= bottom
    float zone_bottom = p_low  // æ”¯æ’‘åŒºåº•éƒ¨æ˜¯æœ€ä½ä»·
    float zone_top = math.max(p_body, p_low)  // æ”¯æ’‘åŒºé¡¶éƒ¨æ˜¯å®ä½“åº•éƒ¨å’Œæœ€ä½ä»·çš„è¾ƒå¤§å€¼
    
    // ç¨å¾®åŠ åšä¸€ç‚¹æ¡†ï¼Œé¿å…å¤ªè–„
    if (zone_top - zone_bottom) < (atr * 0.2)
        zone_top := zone_bottom + (atr * 0.2)  // ç¡®ä¿æœ‰æœ€å°åšåº¦
        
    bool merged = false
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            Zone z = array.get(zones, i)
            if not z.is_broken
                float tolerance = atr * merge_atr
                // é•œåƒï¼šp_low åœ¨æ”¯æ’‘åŒºå†…æˆ–é™„è¿‘
                if p_low >= (z.bottom - tolerance) and p_low <= (z.top + tolerance)
                    z.top    := math.max(z.top, zone_top)  // é•œåƒï¼štop æ˜¯ä¸Šæ²¿
                    z.bottom := math.min(z.bottom, zone_bottom)  // é•œåƒï¼šbottom æ˜¯ä¸‹æ²¿
                    z.touches += 1
                    // ğŸ”¥ æ›´æ–° box çš„æ˜¾ç¤ºä½ç½®
                    box.set_top(z.id, z.top)
                    box.set_bottom(z.id, z.bottom)
                    merged := true
                    break
    if not merged
        // ğŸ”¥ box.new(left, top, right, bottom) - top å¿…é¡»æ˜¯ä»·æ ¼é«˜çš„ï¼Œbottom æ˜¯ä»·æ ¼ä½çš„
        box b = box.new(bar_index - rightLen, zone_top, bar_index, zone_bottom, border_color=col_zone_bd, bgcolor=col_zone_bg, xloc=xloc.bar_index)
        label l = label.new(bar_index, zone_bottom, "", color=col_zone_bd, textcolor=color.white, style=label.style_none)
        array.push(zones, Zone.new(zone_top, zone_bottom, 1, b, l, false, 0))

// ---------------------------------------------------------------------------------------------------------------------}
// 2. æ™ºèƒ½è§†é‡ & ä¿¡å·æ£€æµ‹
// ---------------------------------------------------------------------------------------------------------------------{
bool new_signal = false
bool is_htf = timeframe.isdwm or (timeframe.multiplier >= 240)

if array.size(zones) > 0
    for i = array.size(zones) - 1 to 0
        Zone z = array.get(zones, i)
        
        // --- å¯è§æ€§æ§åˆ¶ ---
        float dist_pct = math.abs(close - z.bottom) / close * 100  // é•œåƒï¼šè·ç¦»åº•éƒ¨
        bool is_visible = true
        if use_smart
            if auto_expand and is_htf
                is_visible := true
            else
                is_visible := (dist_pct <= view_range)

        if not z.is_broken
            if not is_visible
                // ä¸å¯è§æ—¶ï¼Œéšè—
                box.set_bgcolor(z.id, color.new(color.white, 100))
                box.set_border_color(z.id, color.new(color.white, 100))
                label.set_style(z.lbl_count, label.style_none)
                label.set_text(z.lbl_count, "")
            else
                box.set_right(z.id, bar_index + 10)
                // ğŸ”¥ ç¡®ä¿ box çš„ top å’Œ bottom ä¸ Zone æ•°æ®åŒæ­¥
                box.set_top(z.id, z.top)
                box.set_bottom(z.id, z.bottom)
                
                // ğŸ”¥ é•œåƒï¼šå¤±æ•ˆåˆ¤å®š - close < (z.bottom - atr * break_tol)
                if close < (z.bottom - atr * break_tol)
                    z.is_broken := true
                    box.set_bgcolor(z.id, color.new(color.white, 90))
                    box.set_border_color(z.id, color.new(color.white, 85))
                    label.delete(z.lbl_count)
                else
                    // æœ‰æ•ˆçš„æ¡†ï¼šç»¿è‰²
                    box.set_bgcolor(z.id, col_zone_bg)
                    box.set_border_color(z.id, col_zone_bd)
                    if show_touches
                        label.set_xy(z.lbl_count, bar_index + 10, z.bottom)
                        label.set_text(z.lbl_count, str.tostring(z.touches))
                        label.set_style(z.lbl_count, label.style_label_up)
                        label.set_color(z.lbl_count, col_zone_bd)
                    else
                        label.set_style(z.lbl_count, label.style_none)
                        label.set_text(z.lbl_count, "")

        // --- C. ä¿¡å·æ£€æµ‹ (é•œåƒ) ---
        if not z.is_broken and z.touches >= min_touches and not new_signal and z.fail_count < max_retries
            // åŸºç¡€æ¡ä»¶ (é•œåƒ)
            bool touch = low <= z.top  // é•œåƒï¼šlow è§¦ç¢°æ”¯æ’‘åŒºä¸Šæ²¿
            bool is_bull = close > open  // é•œåƒï¼šæ”¶é˜³çº¿
            
            // å†·å´ & ä»·æ ¼è¿‡æ»¤
            bool time_ok = (bar_index - last_sig_idx) > global_cd
            float diff = math.abs(close - last_sig_price) / last_sig_price * 100
            bool price_ok = (last_sig_price == 0.0) or (diff > price_filter)
            bool force_entry = last_trade_hit_sl
            
            bool entry_valid = (time_ok or force_entry) and (price_ok or force_entry) and barstate.isconfirmed
            
            if entry_valid
                // ğŸ”¥ æ¨¡å¼è¯†åˆ« (é•œåƒ)
                // æ¨¡å¼ 1: æ ‡å‡†è§¦ç¢° (Low åœ¨åŒºåŸŸå†…æˆ–ä¸Šæ–¹è§¦ç¢°)
                bool setup_std = touch and is_bull and low >= (z.bottom - atr * 0.1)
                
                // æ¨¡å¼ 2: 2B å‡çªç ´ (Low åˆºç ´äº† Bottomï¼Œä½† Close æ”¶å›æ¥äº†)
                bool setup_2b = low < z.bottom and is_bull
                
                if (setup_std or setup_2b)
                    last_sig_idx := bar_index
                    last_sig_price := close
                    new_signal := true
                    last_trade_hit_sl := false 
                    
                    float trade_sl = z.bottom - (atr * sl_atr_mult)  // é•œåƒï¼šæ­¢æŸåœ¨ä¸‹æ–¹
                    
                    // é›¶æˆæœ¬è®¡ç®— (é•œåƒ)
                    float trade_risk = close - trade_sl
                    float dist_to_zero = trade_risk * (0.7 / 0.3) 
                    float trade_tp_zero = close + dist_to_zero  // é•œåƒï¼šæ­¢ç›ˆåœ¨ä¸Šæ–¹
                    
                    // ğŸ·ï¸ æ ‡ç­¾é€»è¾‘
                    string txt_sig = setup_2b ? "2B" : "L"
                    color col_sig = setup_2b ? col_2b_win : col_l_win
                    
                    label l_lbl = label.new(bar_index, low, txt_sig, color=col_sig, style=label.style_label_up, textcolor=color.white, size=size.small)
                    label i_lbl = label.new(bar_index, low, "", color=color.new(color.white, 100), style=label.style_none, textcolor=col_text, size=size.normal)
                    
                    // è®°å½•
                    Trade t = Trade.new(bar_index, low, atr, trade_sl, trade_tp_zero, l_lbl, i_lbl, true, false, false, i)
                    array.push(trades, t)
                    alert("SRå¤šå•ä¿¡å·è§¦å‘: " + txt_sig, alert.freq_once_per_bar_close)

// ---------------------------------------------------------------------------------------------------------------------}
// 3. äº¤æ˜“è¿½è¸ª (é•œåƒé€»è¾‘)
// ---------------------------------------------------------------------------------------------------------------------{
if array.size(trades) > 0
    int last_idx = array.size(trades) - 1
    
    for k = 0 to last_idx
        Trade t = array.get(trades, k)
        
        if t.is_active
            // --- æ­¢æŸåˆ¤å®š (é•œåƒ) ---
            bool sl_triggered = false
            if use_close_sl
                // æ¨¡å¼ A: å®ä½“æ­¢æŸ (é•œåƒ)
                if close < t.sl_price
                    sl_triggered := true
                if low < (t.sl_price - atr * 1.0) // ç¾éš¾é£æ§ (é•œåƒ)
                    sl_triggered := true
            else
                // æ¨¡å¼ B: å½±çº¿æ­¢æŸ (é•œåƒ)
                if low <= t.sl_price
                    sl_triggered := true
            
            if sl_triggered
                t.is_active := false
                t.hit_sl    := true
                last_trade_hit_sl := true 
                
                if t.zone_idx < array.size(zones)
                    Zone z_ref = array.get(zones, t.zone_idx)
                    z_ref.fail_count += 1
                
                // æ­¢æŸæ ‡ç­¾å˜è‰²
                label.set_color(t.lbl_l, col_l_loss) 
                alert("SRå¤šå•å·²æ­¢æŸ", alert.freq_once_per_bar)
                
            else if high >= t.tp_zero_cost and not t.hit_zero  // é•œåƒï¼šhigh >= tp
                t.hit_zero := true
                // ğŸ’° å›¾æ ‡
                label.new(bar_index, high, "ğŸ’°", style=label.style_none, textcolor=color.yellow, size=size.tiny, yloc=yloc.abovebar)

        // --- æµ®åŠ¨ç›ˆäºæ˜¾ç¤º ---
        bool is_latest = (k == last_idx)
        bool show_this = show_all_info or is_latest
        
        if show_this
            string txt = "SL: " + str.tostring(t.sl_price, format.mintick) + "\n" + 
                         "Risk: -" + str.tostring((t.entry_low - t.sl_price)/t.entry_low*100, "#.2") + "%"
            
            if is_latest and not t.hit_zero and not t.hit_sl
                txt := txt + "\nTarget: " + str.tostring(t.tp_zero_cost, format.mintick)
            label.set_text(t.lbl_info, txt)
            float text_y_pos = t.entry_low - (t.entry_atr * text_offset)  // é•œåƒï¼šåœ¨ä¸‹æ–¹æ˜¾ç¤º
            label.set_xy(t.lbl_info, t.entry_idx, text_y_pos)
            label.set_textcolor(t.lbl_info, t.hit_sl ? color.gray : col_text)
        else
            label.set_text(t.lbl_info, "")

