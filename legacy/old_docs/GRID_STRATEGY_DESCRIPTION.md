# Structure-Weighted Range Grid Strategy - 策略说明文档

## 一、策略核心理念

本策略是一个**结构加权区间网格策略**，基于以下核心思想：

1. **多周期分析**：在更高时间框架（默认4h，可选1d、15m等）上识别关键的支撑/阻力结构，在1分钟（1m）上执行交易
2. **区间震荡假设**：假设价格在支撑和阻力之间震荡，通过网格交易捕捉波动
3. **边缘加权**：在支撑/阻力附近分配更多仓位，因为这些位置反转概率更高
4. **严格风控**：通过突破检测、中轴去库存、微震荡冷却等机制控制风险

---

## 二、数据准备流程

### 2.1 多周期数据获取

```
更高时间框架数据（4h/1d/15m等） → 计算支撑/阻力
    ↓
1分钟数据（1m） → 执行交易
```

**关键特性**：
- **S/R 时间框架可独立配置**：默认使用 **4h**，也可选择 1d、15m 等
- **S/R 数据时间范围独立**：与回测时间范围完全独立
  - 4h：默认 90 天（3个月，约540根）
  - 1d：默认 365 天（1年，约365根）
  - 15m：默认 30 天（约2880根）
- 支撑/阻力通过 `pivot(20,20)` 识别
- 必须应用 **+20 bar 确认滞后**，确保无未来泄露

**配置示例**：
```python
# 使用4h关键位置，过去3个月数据
sr_timeframe = "4h"
sr_days = 90

# 使用1d关键位置，过去1年数据
sr_timeframe = "1d"
sr_days = 365

# 回测时间范围独立配置
backtest_days = 30  # 只回测最近30天
```

### 2.2 支撑/阻力计算流程

```
步骤1: 在更高时间框架（默认4h）上计算 pivot_high 和 pivot_low
       - 使用 pivot(20,20)，即左右各20根K线确认的极值点
       - 基于 close 价格计算（可配置为 high/low）
       - 数据时间范围独立于回测时间范围（例如：用过去3个月找4h关键位置）

步骤2: 应用确认滞后
       confirmed_high = pivot_high.shift(20).ffill()
       confirmed_low = pivot_low.shift(20).ffill()
       
       这意味着：在 bar i 发现的 pivot，要到 bar (i+20) 才被确认为有效
       对于4h：20根 = 80小时 = 约3.3天
       对于1d：20根 = 20天

步骤3: 生成支撑/阻力区间
       support = confirmed_low.ffill()    # 前向填充，保持最新确认的支撑
       resistance = confirmed_high.ffill() # 前向填充，保持最新确认的阻力
       
       只有当 support < resistance 时，区间才有效

步骤4: 广播到1分钟数据
       使用 merge_asof(direction='backward') 将更高时间框架的S/R合并到1m数据
       确保1m数据只能看到已确认的S/R值
       例如：4h的S/R值会应用到所有对应的1m bars上
```

### 2.3 无未来泄露保证

**关键机制**：
- `shift(20)`：确保当前 bar 只能使用 20 根 bar 之前确认的 pivot
- `merge_asof(direction='backward')`：确保 1m 数据只能使用已确认的日线 S/R
- 在任何时间点 t，策略只能看到 t 之前已确认的信息

---

## 三、网格生成逻辑

### 3.1 几何网格间距

网格采用**等百分比间距**（几何级数）：

```
买单价格序列（向下）：
P_buy[k] = P0 × (1 - g)^k
其中：
  - P0 = 当前收盘价
  - g = grid_gap_pct（默认 0.18%）
  - k = 0, 1, 2, ..., max_levels_side

卖单价格序列（向上）：
P_sell[k] = P0 × (1 + g)^k
```

**约束条件**：
- 买单价格必须 ≥ support
- 卖单价格必须 ≤ resistance
- 相邻价格间距 ≥ grid_gap_pct

### 3.2 网格层级限制

- `max_levels_side = 10`：单侧最多 10 层网格
- 实际层数取决于价格是否在 [support, resistance] 区间内

---

## 四、仓位分配策略

### 4.1 边缘加权函数

策略采用**边缘加权**（Edge Weighting），在支撑/阻力附近分配更多仓位：

```
多边权重（距离阻力越近，权重越大）：
w_long(p) = ((resistance - p) / (resistance - support))^α

空边权重（距离支撑越近，权重越大）：
w_short(p) = ((p - support) / (resistance - support))^α

其中：
  - p = 网格价格
  - α = alpha 参数（默认 2.0，控制加权强度）
```

**权重特性**：
- 在支撑附近：空单权重最大，多单权重最小
- 在阻力附近：多单权重最大，空单权重最小
- 在中轴附近：权重较小，避免过度交易

### 4.2 命中衰减机制

**目的**：避免在同一价格水平重复过度交易

```
衰减公式：
w_decayed = w_raw × exp(-hits / decay_k)

其中：
  - hits = 该价格水平的历史成交次数
  - decay_k = 衰减速度参数（默认 2.0）
```

**工作机制**：
- 每次成交后，记录该价格水平的 hit_count
- 下次计算权重时，根据 hit_count 降低权重
- 只保留当前网格价格范围内的 hit_count（自动清理过期记录）

### 4.3 仓位分配流程

```
步骤1: 计算原始权重（边缘加权）
步骤2: 应用命中衰减
步骤3: 归一化权重（使总和为1）
步骤4: 按权重分配总仓位预算
       qty[i] = order_size × normalized_weight[i]
```

---

## 五、订单管理

### 5.1 订单类型

- **限价单（Limit Order）**：所有网格订单都是限价单
- **Maker 费率**：0.02% 每边（模拟币安 maker 费率）
- **无滑点**：回测中假设限价单按设定价格成交

### 5.2 订单生命周期

```
每根 1m bar：
  1. 取消所有未成交的挂单
  2. 检查交易条件（区间有效、价格在区间内、无冷却等）
  3. 生成新的网格价格
  4. 计算权重和仓位
  5. 下新的限价单

订单成交后：
  1. 记录成交价格和数量
  2. 更新 hit_count
  3. 触发镜像补单（保持网格对称性）
```

### 5.3 订单跟踪

- 每个订单都有唯一引用（order.ref）
- 跟踪订单状态：Pending → Partial → Completed / Canceled
- 成交后自动更新 hit_count 和交易日志

---

## 六、风险控制机制

### 6.1 突破检测与退出

**触发条件**：
```
连续 2 根 bar 满足以下任一条件：
  1. close < support - ε（向下突破）
  2. close > resistance + ε（向上突破）

且 ATR(短) / ATR(长) ≥ 1.0（波动放大确认）

其中：
  - ε = ATR(200) × 0.1（突破阈值）
  - ATR(短) = ATR(50)
  - ATR(长) = ATR(200)
```

**执行动作**：
- 撤销所有挂单
- 市价平仓所有持仓
- 进入 "BREAKOUT" 状态，暂停交易
- 直到价格回到有效区间，才恢复交易

### 6.2 中轴去库存（Midline Inventory Reset）

**目的**：防止在价格接近中轴时过度累积仓位

**触发条件**：
```
|close - midline| / midline ≤ mid_band_pct（默认 0.1%）
且 |net_position| > exposure_thresh × max_position（默认 70%）
```

**执行动作**：
- 计算需要减仓的数量：`rebalance_qty = net_position - target`
- 部分平仓，使净仓位降至阈值水平（例如 50%）

### 6.3 微震荡冷却（Micro-Oscillation Cooldown）

**目的**：在低波动期间暂停交易，避免无效交易

**触发条件**：
```
ATR(50) / ATR(200) < micro_atr_ratio（默认 0.6）
```

**执行动作**：
- 跳过网格下单
- 保持现有挂单（不主动取消）
- 等待波动恢复后再继续交易

### 6.4 区间有效性检查

**每根 bar 检查**：
- `range_valid` 必须为 True
- `support` 和 `resistance` 必须有效（非 NaN）
- 当前价格必须在 `[support, resistance]` 区间内

**如果条件不满足**：
- 撤销所有挂单
- 不进行新的交易

---

## 七、策略执行流程

### 7.1 初始化阶段

```
1. 加载日线数据（至少 500 根）
2. 计算支撑/阻力（pivot(20,20) + 20 bar 确认）
3. 加载/生成 1m 数据
4. 将日线 S/R 广播到 1m 数据
5. 初始化策略状态：
   - hit_count 字典（long/short）
   - 突破状态计数器
   - 交易日志
```

### 7.2 每根 bar 执行流程

```
next() 函数执行顺序：

1. 读取当前 bar 数据
   - close, support, resistance, midline
   - atr, atr_short
   - range_valid

2. 突破检测
   - 更新突破计数器
   - 如果突破，撤单+平仓+返回

3. 区间有效性检查
   - 如果无效或价格在区间外，撤单+返回

4. 微震荡冷却检查
   - 如果触发冷却，跳过下单+返回

5. 中轴去库存检查
   - 如果触发，执行部分平仓

6. 生成网格价格
   - 几何级数生成买卖价格
   - 过滤到 [support, resistance] 区间内

7. 计算权重
   - 边缘加权
   - 命中衰减
   - 归一化

8. 分配仓位
   - 按权重分配 order_size

9. 下单
   - 撤销旧订单
   - 下新的限价单
   - 记录订单引用
```

### 7.3 订单回调处理

```
notify_order() 函数：

1. 订单部分/完全成交
   - 记录成交信息
   - 更新 hit_count
   - 记录到交易日志

2. 订单取消/拒绝
   - 清理订单引用
   - 记录日志
```

---

## 八、关键参数说明

### 8.1 网格参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `grid_gap_pct` | 0.0018 (0.18%) | 网格间距百分比 |
| `max_levels_side` | 10 | 单侧最大网格层数 |
| `order_size` | 0.05 | 单侧总仓位预算 |
| `alpha` | 2.0 | 边缘加权强度（1.5~3.0） |
| `decay_k` | 2.0 | 命中衰减速度 |

### 8.2 风险控制参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `exposure_thresh` | 0.7 | 中轴去库存阈值（70%） |
| `mid_band_pct` | 0.001 (0.1%) | 中轴触发带宽 |
| `micro_atr_ratio` | 0.6 | 微震荡冷却阈值 |
| `breakout_epsilon_mult` | 0.1 | 突破阈值倍数（ATR × 0.1） |
| `breakout_atr_ratio` | 1.0 | 突破确认的 ATR 放大倍数 |

### 8.3 支撑/阻力参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `lookback_period` | 20 | Pivot 确认窗口（左右各20根K线） |
| `sr_timeframe` | "4h" | S/R 计算时间框架（"4h", "1d", "15m"等） |
| `sr_days` | None (自动) | S/R 数据的时间范围（天），独立于回测时间范围 |
| `min_sr_bars` | 500 | 最小 S/R 数据量（bars） |

**S/R 时间框架选择建议**：
- **4h（推荐）**：平衡稳定性和响应速度，适合大多数情况
  - 默认数据范围：90天（3个月）
  - 约540根4h bars，足够识别关键结构
- **1d**：更稳定的长期结构，适合趋势市场
  - 默认数据范围：365天（1年）
  - 约365根日线，识别大级别支撑/阻力
- **15m**：更敏感，适合短期震荡
  - 默认数据范围：30天
  - 约2880根15m bars，识别短期结构

**S/R 数据时间范围配置**：
- 可以独立于回测时间范围配置
- 例如：用过去1年的1d数据找关键位置，但只回测最近30天
- 例如：用过去3个月的4h数据找关键位置，但回测最近60天

---

## 九、策略优势

1. **多周期结构**：日线识别大级别结构，1m 执行精细交易
2. **严格无未来泄露**：+20 bar 确认机制确保回测真实性
3. **智能仓位分配**：边缘加权 + 命中衰减，优化资金使用
4. **全面风控**：突破检测、去库存、冷却机制，多维度控制风险
5. **Maker 费率优化**：限价单策略，降低交易成本

---

## 十、策略限制与注意事项

1. **API 限制**：OKX API 单次最多返回 ~3000 根 K 线
   - 解决方案：超过 7 天回测时，从日线生成 1m 数据

2. **区间依赖**：策略只在有效 S/R 区间内交易
   - 如果价格长期在区间外，不会产生交易

3. **网格精度**：从日线生成的 1m 数据精度略低于真实 1m 数据
   - 对于精确回测，建议使用 ≤ 7 天的真实 1m 数据

4. **参数敏感性**：网格间距、加权强度等参数对结果影响较大
   - 建议进行参数扫描优化

---

## 十一、回测输出

### 11.1 性能指标

- 总收益率
- 夏普比率
- 最大回撤
- 年化收益率
- 胜率
- 平均盈利/亏损

### 11.2 交易统计

- 总成交次数（BUY/SELL）
- 总手续费
- 订单填充率
- 网格层级使用分布

### 11.3 导出文件

- `scripts/backtest/results/grid_trades.csv`：所有交易记录
- 包含：时间、方向、价格、数量、手续费、网格价格等

---

## 十二、策略流程图

```
开始
  ↓
配置 S/R 参数
  - sr_timeframe (默认: 4h)
  - sr_days (默认: 90天 for 4h)
  - 回测时间范围 (days)
  ↓
加载更高时间框架数据（4h/1d等）
  - 时间范围：过去 sr_days 天
  - 例如：4h 用过去90天，1d 用过去365天
  ↓
计算 pivot(20,20)
  ↓
应用 +20 bar 确认滞后
  ↓
生成 support/resistance
  ↓
加载/生成 1m 数据
  - 时间范围：过去 days 天（回测期间）
  - 与 S/R 数据时间范围独立
  ↓
广播 S/R 到 1m
  - 使用 merge_asof 确保无未来泄露
  ↓
┌─────────────────┐
│   每根 1m bar   │
└─────────────────┘
  ↓
检查突破？ → 是 → 撤单+平仓 → 暂停
  ↓ 否
检查区间有效？ → 否 → 撤单 → 跳过
  ↓ 是
检查冷却？ → 是 → 跳过下单
  ↓ 否
检查中轴去库存？ → 是 → 部分平仓
  ↓
生成几何网格价格
  ↓
计算边缘权重
  ↓
应用命中衰减
  ↓
分配仓位
  ↓
撤销旧订单
  ↓
下新的限价单
  ↓
等待成交/取消
  ↓
更新 hit_count
  ↓
记录交易日志
  ↓
继续下一根 bar
```

---

## 十三、配置示例

### 13.1 默认配置（4h，3个月）

```python
main(
    symbol="BTCUSDT",
    days=30,              # 回测最近30天
    sr_timeframe="4h",    # 使用4h时间框架
    sr_days=90,           # S/R数据用过去90天（3个月）
    min_sr_bars=500,      # 至少500根4h bars
)
```

### 13.2 日线关键位置（1年数据）

```python
main(
    symbol="BTCUSDT",
    days=30,              # 回测最近30天
    sr_timeframe="1d",    # 使用日线
    sr_days=365,          # S/R数据用过去1年
    min_sr_bars=365,      # 至少365根日线
)
```

### 13.3 自定义配置

```python
main(
    symbol="BTCUSDT",
    days=60,              # 回测最近60天
    sr_timeframe="4h",    # 使用4h
    sr_days=180,          # S/R数据用过去6个月（更长的历史）
    min_sr_bars=1000,      # 至少1000根4h bars
)
```

### 13.4 命令行使用

```bash
# 格式：python run_backtest_m2.py [use_real] [symbol] [backtest_days] [sr_timeframe] [sr_days] [min_sr_bars]

# 默认：4h，3个月，回测30天
python run/run_backtest_m2.py

# 4h，3个月，回测60天
python run/run_backtest_m2.py true BTCUSDT 60 4h 90

# 1d，1年，回测30天
python run/run_backtest_m2.py true BTCUSDT 30 1d 365

# 4h，6个月，回测30天
python run/run_backtest_m2.py true BTCUSDT 30 4h 180
```

## 十四、与 TradingView 对比验证

### 14.1 Pivot 点验证

在 TradingView 中使用：
```pinescript
// 注意：时间框架要与策略配置一致（默认4h）
pivot_high = ta.pivothigh(close, 20, 20)
pivot_low = ta.pivotlow(close, 20, 20)
```

对比我们的 `pivot_high` 和 `pivot_low` 列，应该完全一致。

**重要**：确保 TradingView 的时间框架与策略的 `sr_timeframe` 一致（默认4h）。

### 14.2 支撑/阻力验证

**注意**：TradingView 显示的是 pivot 点，我们显示的是确认后的值。

- TradingView 的 pivot 在 bar i
- 我们的 support/resistance 在 bar (i+20) 才出现

这是**设计行为**，确保无未来泄露。

**验证步骤**：
1. 在 TradingView 中切换到对应时间框架（默认4h）
2. 找到 pivot 点的时间戳
3. 在我们的 CSV 中，该 pivot 的确认时间应该是 pivot时间 + 20根K线
4. 对于4h：确认时间 = pivot时间 + 80小时（约3.3天）

---

## 十五、优化建议

1. **S/R 时间框架优化**：
   - **4h（推荐）**：平衡稳定性和响应速度
   - **1d**：更稳定的长期结构，适合趋势市场
   - **15m**：更敏感，适合短期震荡
   - 测试不同时间框架对策略表现的影响

2. **S/R 数据时间范围优化**：
   - 4h：测试 60天、90天、180天
   - 1d：测试 180天、365天、730天
   - 更长历史可能识别更多关键结构，但也可能包含过时信息

3. **网格参数扫描**：
   - `grid_gap_pct`: 0.0005 ~ 0.003
   - `alpha`: 1.5 ~ 3.0
   - `order_size`: 0.01 ~ 0.1

4. **多市场测试**：
   - 不同交易对（BTC, ETH 等）
   - 不同市场环境（震荡、趋势）

5. **风险参数调优**：
   - 突破阈值
   - 去库存阈值
   - 冷却阈值

6. **Pivot 参数优化**：
   - 测试不同 `lookback_period`（15, 20, 25, 30）
   - 不同 pivot_source（close, high, low）

---

## 十六、总结

这是一个**结构驱动的区间网格策略**，核心特点是：

1. **多周期结构识别**：更高时间框架（默认4h）找结构，1m 做交易
2. **灵活配置**：S/R 时间框架和数据范围可独立配置
   - 默认：4h 时间框架，过去3个月数据
   - 可切换：1d（1年）、15m（1个月）等
3. **严格无未来泄露**：+20 bar 确认机制
4. **智能仓位管理**：边缘加权 + 命中衰减
5. **全面风险控制**：突破、去库存、冷却三重保护
6. **Maker 费率优化**：限价单策略降低成本

**策略适用场景**：
- **震荡市场**：价格在支撑/阻力区间内波动
- **结构清晰**：有明显的关键支撑/阻力位置
- **多时间框架**：通过更高时间框架识别结构，在1m上精细执行

**配置建议**：
- **新手**：使用默认配置（4h，3个月）
- **长期策略**：使用1d时间框架，1年数据
- **短期策略**：使用15m时间框架，1个月数据
- **自定义**：根据市场特性调整 `sr_timeframe` 和 `sr_days`

