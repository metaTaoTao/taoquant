# 部分平仓问题分析

## 问题现状

### 1. VectorBT的限制
**为什么不支持部分平仓？**
- **向量化架构**：VectorBT使用NumPy向量化操作，所有计算都是"批量"的
- **信号驱动**：只能处理entry/exit信号，不能处理"部分exit"
- **设计哲学**：为了速度牺牲了灵活性
- **本质**：向量化 = 并行处理所有bars，无法处理"状态依赖"的操作

**结论**：VectorBT的架构决定了它无法支持部分平仓，除非：
- 修改VectorBT源码（不现实）
- 用多个"虚拟仓位"模拟（复杂且不准确）

### 2. backtesting.py的限制
**为什么对crypto分数位支持不好？**
- **设计初衷**：主要面向股票（整数股）
- **分数位处理**：虽然理论上支持，但可能有精度问题
- **部分平仓**：理论上可以通过`order_target_percent()`实现，但：
  - 需要验证是否真的支持crypto的分数位
  - 可能有精度/舍入问题

**需要验证的点**：
- 能否持有0.123456 BTC这样的分数位？
- 能否精确地平掉30%（比如从1 BTC平到0.7 BTC）？
- 手续费计算是否正确？

## 解决方案分析

### 方案1：自定义事件驱动引擎 ⭐⭐⭐⭐⭐
**实现方式**：
- 自己写一个简单的事件驱动引擎
- 完全控制仓位管理
- 支持部分平仓、trailing stop等所有功能

**优点**：
- ✅ 完全控制，没有限制
- ✅ 可以精确实现任何逻辑
- ✅ 不需要依赖外部框架
- ✅ 可以优化性能（只实现需要的功能）

**缺点**：
- ❌ 需要自己实现（但不算复杂）
- ❌ 需要自己处理手续费、滑点等

**工作量**：
- 核心引擎：2-3天
- 测试和优化：1-2天
- 总计：3-5天

### 方案2：验证backtesting.py ⭐⭐⭐
**实现方式**：
- 先测试backtesting.py是否真的支持分数位和部分平仓
- 如果支持，就用它
- 如果不支持，放弃

**优点**：
- ✅ 如果支持，可以直接用
- ✅ 有现成的可视化

**缺点**：
- ❌ 可能不支持（需要验证）
- ❌ 即使支持，可能有精度问题

**工作量**：
- 测试：半天
- 如果支持，集成：1-2天
- 如果不支持，放弃，回到方案1

### 方案3：使用Backtrader ⭐⭐
**实现方式**：
- 使用Backtrader框架
- 实现BacktestEngine接口

**优点**：
- ✅ 功能强大，支持部分平仓
- ✅ 有完整的文档

**缺点**：
- ❌ 学习曲线陡峭
- ❌ API复杂
- ❌ 性能一般
- ❌ 需要大量适配代码

**工作量**：
- 学习：2-3天
- 实现：3-5天
- 总计：5-8天

### 方案4：修改策略逻辑（变通方案）⭐⭐⭐
**实现方式**：
- 不真正"部分平仓"
- 而是用"多个仓位"模拟：
  - 开仓时：开2个仓位（30% + 70%）
  - TP1时：平掉30%的仓位
  - 剩余70%用trailing stop

**优点**：
- ✅ 可以在VectorBT中实现
- ✅ 不需要换框架

**缺点**：
- ❌ 逻辑复杂
- ❌ 需要管理多个"虚拟仓位"
- ❌ 不是真正的部分平仓

**工作量**：
- 实现：2-3天
- 测试：1天
- 总计：3-4天

## 推荐方案

### 短期（立即）：方案4（变通）
**理由**：
- 最快实现
- 不需要换框架
- 可以验证策略逻辑是否正确

**实现思路**：
```python
# 开仓时：开2个仓位
entry_signal_30pct = entry & (condition_for_30pct)
entry_signal_70pct = entry & (condition_for_70pct)

# TP1时：平掉30%的仓位
exit_signal_30pct = (profit >= tp1_target) & (position_30pct_open)

# 剩余70%用trailing stop
exit_signal_70pct = trailing_stop_logic & (position_70pct_open)
```

### 长期（1-2周）：方案1（自定义引擎）
**理由**：
- 最灵活，没有限制
- 可以精确实现任何逻辑
- 性能可控
- 不依赖外部框架

**实现思路**：
- 事件驱动：逐bar处理
- 仓位管理：精确跟踪每个仓位
- 部分平仓：直接支持
- 性能：只实现需要的功能，可以很快

## 决策树

```
需要部分平仓？
├─ 是
│  ├─ 可以接受"多个仓位"模拟？
│  │  ├─ 是 → 方案4（变通，用VectorBT）
│  │  └─ 否
│  │     ├─ backtesting.py支持分数位？
│  │     │  ├─ 是 → 方案2（用backtesting.py）
│  │     │  └─ 否 → 方案1（自定义引擎）⭐
│  │     └─ 愿意学习Backtrader？
│  │        ├─ 是 → 方案3（Backtrader）
│  │        └─ 否 → 方案1（自定义引擎）⭐
│  └─ 否 → 继续用VectorBT
```

## 我的建议

**立即行动**：
1. 先用方案4（变通）验证策略逻辑
2. 同时测试backtesting.py是否支持分数位（方案2）

**如果backtesting.py不支持**：
- 实现方案1（自定义引擎）
- 这是最可靠的长期方案

**时间线**：
- 第1周：方案4实现 + backtesting.py测试
- 第2周：如果backtesting.py不支持，实现自定义引擎
- 第3周：测试和优化

## 关键问题

1. **backtesting.py是否真的支持crypto分数位？**
   - 需要实际测试
   - 测试文件存在，但可能没通过

2. **自定义引擎的性能如何？**
   - 事件驱动比向量化慢，但对于单资产策略，通常够用
   - 可以优化关键路径

3. **"多个仓位"模拟是否准确？**
   - 逻辑上等价，但实现复杂
   - 可以作为临时方案

